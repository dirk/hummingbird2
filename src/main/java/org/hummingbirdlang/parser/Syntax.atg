COMPILER Syntax

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = nonZeroDigit + "0".
tab = '\t'.
lf = '\n'.
cr = '\r'.
stringChar = ANY - "\"" - '\\' - cr - lf.

TOKENS

identifier = letter {letter | digit}.
let = "let".
var = "var".

COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/"

PRODUCTIONS

Syntax =
  Program<out Object statements>
                                 (. this.program = statements; .)
  .

Program<out Object result> =
  ProgramStatements<out result>.

ProgramStatements<out Object result> =
                                    (. List<Object> body = new ArrayList<>(); .)
  {
    Statement<out Object statement> (. body.add(statement); .)
  }
                                    (. result = body; .)
  .

Statement<out Object result> =
                                 (. result = null; .)
  (
      LetDeclaration<out result>
    | VarDeclaration<out result>
  )
  .

LetDeclaration<out Object result> =
  let
  "="
  Expression<out Object expression> (. result = expression; .)
  .

VarDeclaration<out Object result> =
  var
  "="
  Expression<out Object expression> (. result = expression; .)
  .

Expression<out HBExpressionNode result> =
  TernaryExpression<out result>.

TernaryExpression<out HBExpressionNode result> =
                                                                  (. result = null; .)
  LogicalOrExpression<out HBExpressionNode condOrValueExpression>
  [
    "?" LogicalOrExpression<out HBExpressionNode thenExpression>
    ":" LogicalOrExpression<out HBExpressionNode elseExpression>
  ]
  .

LogicalOrExpression<out HBExpressionNode result> =  (. result = null; .)
  LogicalAndExpression<out HBExpressionNode left>
  [
    "||"
    LogicalOrExpression<out HBExpressionNode right>
  ]
  .

LogicalAndExpression<out HBExpressionNode result> =  (. result = null; .)
  GroupOrTupleExpression<out HBExpressionNode left>  (. result = left; .)
  [
    "&&"
    LogicalAndExpression<out HBExpressionNode right> (. result = new HBLogicalAndNode(left, right); .)
  ]
  .

GroupOrTupleExpression<out HBExpressionNode result> = (. result = null; .)
  (
    (
                                                      (. boolean isTuple = false; .)
      "("
      Expression<out Object expression>
      [
                                                      (. isTuple = true;
                                                         List<Object> elements = new ArrayList<>();
                                                         elements.add(expression); .)
        ","
        [
          Expression<out Object secondElement>        (. elements.add(secondElement); .)
          {
            ","
            Expression<out Object nextElement>        (. elements.add(nextElement); .)
          }
        ]
      ]
      ")"
    )                                                 (. result = null; /* TODO: Tuple expression! */ .)
  |
    SuffixExpression<out HBExpressionNode suffix>     (. result = suffix; .)
  )
  .

SuffixExpression<out HBExpressionNode result> = (. result = null; .)
  Atom<out HBExpressionNode atom>
  [
    Suffix<out result, atom>
  ]
  .

Atom<out HBExpressionNode result> =
  identifier (. result = new HBIdentifierNode(t); .)
  .

Suffix<out HBExpressionNode result, HBExpressionNode parent> =
                                                               (. result = null; .)
  (
      (
          "("                                                  (. HBExpressionNode parameter;
                                                                  List<HBExpressionNode> parameters = new ArrayList<>(); .)
          [
            Expression<out parameter>                          (. parameters.add(parameter); .)
            {
              ","
              Expression<out parameter>                        (. parameters.add(parameter); .)
            }
          ]
          ")"                                                  (. result = new HBCallNode(parent, parameters.toArray(new HBExpressionNode[parameters.size()])); .)
        |
          "["
          Expression<out Object indexer>
          "]"
        |
          "."
          identifier
      )
      [
        Suffix<out result, result>
      ]
    |
      // Assignment must be last so we avoid the recursive branch.
      Assignment
  )
  .

Assignment =
  "="
  Expression<out HBExpressionNode newValue>
  .

END Syntax.
